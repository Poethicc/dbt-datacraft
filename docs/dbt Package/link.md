---
category: main
step: 3_raw
sub_step: 
doc_status: ready
---
# macro `link`

## List of auxiliary macros

```dataview
TABLE 
category AS "Category", 
in_main_macro AS "In Main Macro",
doc_status AS "Doc Status"
FROM "dbt Package"
WHERE file.name != "README" AND contains(in_main_macro, "link")
SORT doc_status
```

## Описание

Макрос `link` предназначен для дедупликации данных. Макрос собирает сведения о типах данных столбцов, группирует данные по всем нечисловым колонкам, и суммирует данные по числовым. Таким образом, если в данных были избыточные строки, они уйдут из данных на этом шаге.
## Применение

Имя dbt-модели (=имя файла в формате sql в папке models) должно соответствовать шаблону:
`link_{название_пайплайна}`.

Например, `link_events`.

Внутри этого файла вызывается макрос:

```sql
{{ etlcraft.link() }}
```
Над вызовом макроса в файле будет указана зависимость данных через `—depends_on`. То есть целиком содержимое файла выглядит, например, вот так:
```sql
-- depends_on: {{ ref('hash_events') }}

{{ etlcraft.link() }}
```
## Аргументы

Этот макрос принимает следующие аргументы:

1. `params` (по умолчанию: none)
2.  `disable_incremental` (по умолчанию: none)
3. `override_target_model_name` (по умолчанию: none)
4. `date_from` (по умолчанию: none)
5. `date_to` (по умолчанию: none)
6. `limit0` (по умолчанию: none)
## Функциональность

Сначала макрос считает имя модели - либо из передаваемого аргумента (  
`override_target_model_name`), либо из имени файла (`this.name`). При использовании аргумента `override_target_model_name` макрос работает так, как если бы находился в модели с именем, равным значению `override_target_model_name`.

Название модели, полученное тем или иным способом, разбивается на части по знаку нижнего подчёркивания. Из этой информации макрос сформирует название модели, из которой будет брать данные.

По возможности макрос задаст инкрементальность. Для этой задачи и для будущего распределения колонок по категориям используется дополнительный макрос `get_columns_in_relation`.

Если в таблице-источнике есть поля с датой, то будет следующая материализация:
```sql

{{ config(

    materialized='incremental',

    order_by=('__date', '__table_name'),

    incremental_strategy='delete+insert',

    unique_key=['__date', '__table_name'],

    on_schema_change='fail'

) }}
```
если нет:
```sql

{{ config(

    materialized='table'

) }}
```
  
Далее макрос будет работать с колонками и типами данных, чтобы распределить данные из таблицы-источника на 2 типа: данные числовые, данные не числовые. Данные числовые будут агрегироваться, а данные не числовые будут служить основой для группировки.

Для этого сначала задаются наименования числовых типов данных:
```sql

{%- set numeric_types = ['UInt8', 'UInt16', 'UInt32', 'UInt64', 'UInt256',

                        'Int8', 'Int16', 'Int32', 'Int64', 'Int128', 'Int256',

                        'Float8', 'Float16','Float32', 'Float64','Float128', 'Float256','Num'] -%}
```
  
Далее будет происходить формирование автоматического SQL-запроса.

В блоке SELECT будут перечисляться колонки не числового типа, и тут же они будут добавляться в список, который будет использован в блоке GROUP BY.

Данные по колонкам с числовым типом данных будут суммироваться.

Таким образом, если в данных были дубликаты/избыточные строки, они уйдут из данных на этом шаге.
 
Если аргумент `limit0` активирован, то в конце SQL-запроса будет добавлено `LIMIT 0`.

## Пример

Файл в формате sql в папке models. Название файла `link_events`

Содержимое файла:
```sql
-- depends_on: {{ ref('hash_events') }}

{{ etlcraft.link() }}
```

## Примечания

Это шестой из основных макросов.