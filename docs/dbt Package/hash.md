---
category: main
step: 2_staging
sub_step: 3_hash
doc_status: ready
language: rus
main_number: "05"
---
# macro `hash`

## Список используемых вспомогательных макросов
| Name            | Category  | In Main Macro | Doc Status |
| --------------- | --------- | ------------- | ---------- |
| [[entity_hash]] | auxiliary | hash          | ready      |
| [[link_hash]]   | auxiliary | hash          | ready      |
| [[zero_date]]   | auxiliary | hash          | ready      |

## Описание

Макрос `hash` предназначен для добавления к данным хэш-столбцов. В дальнейшем эти столбцы пригодятся для дедупликации данных.
## Применение

Имя dbt-модели (=имя файла в формате sql в папке models) должно соответствовать шаблону:
`hash_{название_пайплайна}`.

Например, `hash_events`.

Внутри этого файла вызывается макрос:

```sql
{{ datacraft.hash() }}
```
Над вызовом макроса в файле будет указана зависимость данных через `—depends_on`. То есть целиком содержимое файла выглядит, например, вот так:
```sql
-- depends_on: {{ ref('combine_events') }}

{{ datacraft.hash() }}
```
## Аргументы

Этот макрос принимает следующие аргументы:

1. `params` (по умолчанию: none)
2.  `disable_incremental` (по умолчанию: none)
3. `override_target_model_name` (по умолчанию: none)
4. `metadata` (по умолчанию: результат макроса `project_metadata()`)
5. `date_from` (по умолчанию: none)
6. `date_to` (по умолчанию: none)
7. `limit0` (по умолчанию: none)

## Функциональность

Сначала макрос считает имя модели - либо из передаваемого аргумента (  
`override_target_model_name`), либо из имени файла (`this.name`). При использовании аргумента `override_target_model_name` макрос работает так, как если бы находился в модели с именем, равным значению `override_target_model_name`.

Название модели, полученное тем или иным способом, разбивается на части по знаку нижнего подчёркивания. Например, название `hash_events` разобьётся на 2 части, из этих частей макрос возьмёт в работу:

- пайплайн - `pipeline_name` → events

Для пайплайна `registry` макрос возьмёт ещё линк.
Если пайплайн относится к `datestat` или `events`, то материализация будет инкрементальной:

```sql

{{ config(

    materialized='incremental',

    order_by=('__date', '__table_name'),

    incremental_strategy='delete+insert',

    unique_key=['__date', '__table_name'],

    on_schema_change='fail'

) }}
```
В других случаях - обычной:

```sql
{{ config(

    materialized='table',

    order_by=('__table_name'),

    on_schema_change='fail'

) }}
```
Если имя модели не соответствует шаблону - макрос выдаст  ошибку.

Далее макрос задаст паттерн, чтобы найти combine-таблицу нужного пайплайна.
Паттерн для пайплайна `registry`:

`'combine_' ~ pipeline_name ~'_'~ link_name`

Для других пайплайнов:

`'combine_' ~ pipeline_name`

Далее макрос будет работать с `metadata`.

Из метадаты будут отобраны названия всех линков проекта. Для каждого линка будут получены данные по нему - `pipeline`, `datetime_field`, `main_entities`, `other_entities`.

Далее будут отбираться такие сущности, для которых либо условие `glue=yes`, либо эта сущность входит в `main_entities`. Сущности отбираются по этим двум условиям, затем полученный список становится уникальным.

Из уникального списка сущностей отбираем те, которые либо есть в списке сущностей `glue='yes'`, либо есть в разделе `registries`.

Для моделей пайплайна `registry` отбираем линки и сущности отдельно, чтобы выводить модели по-отдельности для каждого источника данных.

Например, у модели пайплайна `registry` есть в названии линк A - макрос идёт в метадату и отбирает всю информацию по этому линку A. Для модели с другим линком - B - макрос отберёт информацию по линку B. 

Далее все ранее полученные данные будут использоваться при генерировании SQL-запроса.

Макрос обращается к ранее найденной при помощи паттерна таблице-источнику  и берёт оттуда данные. Макрос добавляет: 
- хэши для отобранных линков при помощи макроса [[link_hash]] 
- хэши для отобранных сущностей при помощи макроса [[entity_hash]]
  
Далее на основе этих данных формируется поле `__id` и поле `__datetime`. 
Для создания поля `__id` макрос перебирает отобранные линки, и когда он находит тот, который совпадает со значением в поле `__link` (это поле и его значение задаются на шаге `join`), то он из этого линка и создаёт `__id`.

```sql

SELECT *,

  assumeNotNull(CASE

{%- for link in links_list %}

    {%- set link_hash = link ~ 'Hash' %}  

    WHEN __link = '{{link}}'

    THEN {{link_hash}}

{% endfor %}

    END) as __id
```
Для того, чтобы сформировать поле `__datetime` ,  макрос смотрит в метадату. Если поле datetime_field из метадаты для отобранного линка есть, то макрос приводит его к формату даты. Если такого поля в метадате нет, то макрос приведёт дефолтное поле к формату даты через дополнительный макрос [[zero_date]].

Если аргумент `limit0` активирован, то в конце SQL-запроса будет добавлено `LIMIT 0`.

Также в конце этого макроса есть дополнительная настройка для повышения производительности, которую можно активировать (по дефолту она в закомментированном виде):
```sql
-- SETTINGS short_circuit_function_evaluation=force_enable
```

## Пример

Файл в формате sql в папке models. Название файла `hash_events`

Содержимое файла:
```sql
-- depends_on: {{ ref('combine_events') }}

{{ datacraft.hash() }}
```

## Примечания

Это пятый из основных макросов.