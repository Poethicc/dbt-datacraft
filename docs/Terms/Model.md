---
term_name: Модель
description: Файл расширения .sql, с помощью которого dbt создает таблицу или view.
type: term
doc_status: ready (нужно ревью)
---
В контексте использования [dbt](https://docs.getdbt.com/docs/introduction) (Data Build Tool), **модель** (model) — это ключевой компонент, представляющий собой SQL-запрос или набор SQL-запросов, который определяет процесс трансформации данных. Модели в dbt описывают, каким образом данные должны преобразовываться, объединяться и обогащаться для построения структурированных таблиц или представлений в базе данных, на основе которых можно проводить аналитические расчёты.
## Основные аспекты модели в dbt:
1. **SQL-файл с трансформациями**:
	- Каждая модель в dbt создаётся как SQL-файл, в котором описывается набор SQL-инструкций для выполнения определённых преобразований данных. Эти файлы обычно находятся в папке `/models` в [проекте dbt](https://docs.getdbt.com/docs/build/projects).
	- В SQL-файле модели могут быть различные инструкции, такие как `SELECT`, `JOIN`, `GROUP BY` и другие, чтобы создать целевую таблицу или представление с нужной структурой и агрегатами. В случае с **dataCraft Core** и входящего в него [[dbt Package/README|dbt Package]], каждая модель содержит вызов определённого [макроса](https://docs.getdbt.com/docs/build/jinja-macros) из `dbt Package`.
2. **Слои моделей**:
    - Модели в dbt можно разделить на несколько уровней/слоёв, например, такие как **Staging** (первичная обработка сырых данных), **Intermediate** (промежуточные слои для объединения и фильтрации данных), и **Marts** (итоговые таблицы для аналитических расчётов и визуализаций). [Подробнее про структурирование моделей в dbt проекте](https://docs.getdbt.com/best-practices/how-we-structure/1-guide-overview)
		По методологии **dataCraft Core** обработка данных также разделяется на несколько крупных слоёв, каждый из которых делится на более мелкие. Подробнее про слои в [[dbt Package/README|dbt Package]].
    - Структурирование моделей по слоям помогает организовать трансформации данных и улучшить читаемость проекта.
3. **Материализация моделей**:
    - dbt позволяет выбирать способ материализации моделей. Основные варианты — **table** (таблица) и **view** (представление), но также можно использовать **incremental** (инкрементальные обновления) и **ephemeral** (временные таблицы, которые хранятся только в памяти). Подробнее про материализацию в [официальной документации](https://docs.getdbt.com/docs/build/materializations). 
    - Выбор материализации важен для оптимизации работы с данными, так как разные подходы имеют разные требования к производительности и затратам на хранение.
4. **Связь моделей и управление зависимостями**:
    - Модели могут ссылаться друг на друга с помощью макроса `ref()`, что позволяет создавать зависимые цепочки трансформаций.
    - dbt автоматически отслеживает зависимости между моделями, создавая «граф зависимостей». Это упрощает управление обновлениями данных и упорядочение выполнения запросов.

## Правила наименования моделей в dataCraft Core по слоям

#### ==Слой - 1_silos==
- **Подслой - 1_normalize**
	`normalize_{название_источника}_{название_пайплайна}_{название_шаблона}_{название_потока}`
- **Подслой - 2_incremental**
	`incremental_{название_источника}_{название_пайплайна}_{название_шаблона}_{название_потока}`

#### ==Слой - 2_staging==
- **Подслой - 1_join**
	- `join_{название источника}_{название пайплайна}` - для всех пайплайнов, кроме Registry (глобального)
	- `join_{название источника}_{название пайплайна}_{название линка}` - для Registry (глобального)
- **Подслой - 2_combine** 
	- `combine_{название пайплайна}` - для всех пайплайнов, кроме Registry (глобального)
	- `combine_{название пайплайна}_{название линка}` - для Registry (глобального)
- **Подслой - 3_hash** 
	- `hash_{название_пайплайна}` - для всех пайплайнов, кроме Registry (глобального)
	- `hash_{название_пайплайна}_{название линка}` - для Registry (глобального)

#### ==Слой - 3_raw==
- **Подслой - link** 
	- `link_{название_пайплайна}` - для всех пайплайнов, кроме Registry (глобального)
	- `link_{название_пайплайна}_{название линка}` - для Registry (глобального)

#### ==Слой - 4_graph==
В данном случае для всех подслоёв название файла модели формируется по одинаковой схеме:
	`graph_{название_подслоя}`
Перечень подслоёв на шаге `graph`:
- 1_tuples                     
- 2_lookup                       
- 3_unique
- 4_edge                          
- 5_glue                          
- 6_qid                           

#### ==Слой - 5_full==
	 full_{название пайплайна}

#### ==Слой - 6_attribution==
В данном случае для всех подслоёв название файла модели формируется по одинаковой схеме:
	`attr_{название модели атрибуции}_{название_подслоя}`
Перечень подслоёв на шаге `attribution`:
- 1_prepare 
- 2_create_events
- 3_add_row_number
- 4_find_new_period 
- 5_calculate_period_number 
- 6_create_missed_steps
- 7_join_to_attr_prepare_with_qid
- 8_model  
- 9_final_table     

#### ==Слой - 7_dataset==
	dataset_{название датасета}


## Пример модели в dataCraft Core
```sql
-- depends_on: {{ ref('normalize_appmetrica_events_default_deeplinks') }}
{{ datacraft.incremental() }}
```
*Содержимое файла модели на слое 1_stage, подслое 2_incremental - вызов макроса incremental() из [[dbt Package/README|пакета dbt]]
